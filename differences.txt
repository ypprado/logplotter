diff --git a/app/scripts/parser-sym.js b/app/scripts/parser-sym.js
index 2d98b13..a050aa5 100644
--- a/app/scripts/parser-sym.js
+++ b/app/scripts/parser-sym.js
@@ -1,249 +1,298 @@
-/** 
- * Parses the SYM file content into structured data, including enumerations,
- * multiplexors, metadata, and multi-line enums.
+/**
+ * Parses the SYM file content into structured data matching parser expectations.
  * @param {string} content - The raw SYM file content.
- * @returns {Object} - Parsed messages, nodes, and file-level metadata.
+ * @returns {{ messages: Array, nodes: Array }} - Parsed messages and nodes.
  */
 export function parseSYM(content) {
-  const rawLines = content.split("\n");
-  const lines = [];
-  rawLines.forEach(l => lines.push(l.trim()));
-
+  const lines = content.split("\n").map(l => l.trim());
   const messages = [];
   const nodes = new Set();
-  const signals = {};
+  const signalsDefs = {};
   const enumerations = {};
 
-  let formatVersion;
-  let title;
-
-  // Pre‐scan for FormatVersion and Title
-  for (let line of lines) {
-    if (line.startsWith("FormatVersion=")) {
-      formatVersion = line.replace(/^FormatVersion=/, "")
-                          .replace(/\/\/.*$/, "")
-                          .trim();
-    }
-    if (line.startsWith("Title=")) {
-      title = line.replace(/^Title=/, "")
-                  .replace(/^"/, "")
-                  .replace(/"$/, "")
-                  .trim();
-    }
-  }
-
-  // First Pass: multi-line enum extraction
+  // 1) Extract multi-line enums
   for (let i = 0; i < lines.length; i++) {
-    let line = lines[i];
-    if (line.startsWith("Enum=")) {
-      let accum = line;
-      while (!accum.includes(")")) {
-        i++;
-        if (i >= lines.length) break;
-        accum += " " + lines[i];
-      }
-      const m = accum.match(/^Enum=([^()]+)\(([\s\S]+)\)$/);
-      if (m) {
-        const name = m[1].trim();
-        const pairs = m[2]
-          .split(/,(?=(?:[^"]*"[^"]*")*[^"]*$)/)
-          .map(p => p.trim())
-          .filter(Boolean);
-        const map = {};
-        pairs.forEach(pair => {
-          const [k, v] = pair.split("=").map(x => x.trim().replace(/^"|"$/g, ""));
-          map[k] = v;
-        });
-        enumerations[name] = map;
-      }
+    if (!lines[i].startsWith("Enum=")) continue;
+    let accum = lines[i];
+    while (!accum.includes(")")) {
+      i++;
+      if (i >= lines.length) break;
+      accum += " " + lines[i];
     }
+    const m = accum.match(/^Enum=([^()]+)\(([\s\S]+)\)$/);
+    if (!m) continue;
+    const name = m[1].trim();
+    const entries = m[2]
+      .split(/,(?=(?:[^"]*"[^"]*")*[^"]*$)/)
+      .map(p => p.trim())
+      .filter(Boolean);
+    const map = {};
+    entries.forEach(p => {
+      const [k, v] = p.split("=").map(x => x.trim().replace(/^"|"$/g, ""));
+      map[k] = v;
+    });
+    enumerations[name] = map;
   }
 
-  // Second Pass: collect all global signal definitions
-  for (let line of lines) {
+  // 2) Global signal definitions (Sig= lines anywhere)
+  for (const line of lines) {
     const sigMatch = line.match(/^Sig="?([^"]+)"?\s+(\w+)\s+(\d+)(\s+-m)?/);
     if (!sigMatch) continue;
 
-    const name = sigMatch[1];
-    const rawType = sigMatch[2].toLowerCase();
-    const length = parseInt(sigMatch[3], 10);
-    const isBig = !!sigMatch[4];
-
-    // valueType
-    let valueType;
-    if (rawType === "string") {
-      valueType = "String";
-    } else if (rawType === "unsigned") {
-      valueType = "Unsigned";
-    } else {
-      valueType = "Signed";
-    }
+    const [ , name, rawTypeRaw, lenRaw, muxFlag ] = sigMatch;
+    const rawType = rawTypeRaw.toLowerCase();
+    const length  = parseInt(lenRaw, 10);
+    const isBig   = !!muxFlag;
+
+    const valueType =
+      rawType === "string"   ? "String"   :
+      rawType === "unsigned" ? "Unsigned" : "Signed";
 
-    signals[name] = {
+    signalsDefs[name] = {
       name,
       length,
-      byteOrder: isBig ? "BigEndian" : "LittleEndian",
+      byteOrder:        isBig ? "BigEndian" : "LittleEndian",
       valueType,
-      scaling: 1.0,
-      offset: 0.0,
-      valueRange: [0, 1],
-      units: "",
-      valueDescriptions: {},
-      description: "",
-      // mark multiplexer if "-m" present
-      isMultiplexer: !!sigMatch[4],
-      // value placeholder; actual multiplexed signals handled by Mux= lines
-      multiplexerValue: undefined,
+      scaling:          1.0,
+      offset:           0.0,
+      valueRange:       [0, 1],
+      units:            "",
+      description:      "",
+      valueDescriptions:{},
+      defaultValue:     0,
+      isMultiplexer:    isBig
     };
 
-    // attributes (/f:, /o:, /min:, /max:, /u:, /e:)
-    const attrs = line.match(/\/[fo]:(-?\d+(\.\d+)?)|\/min:(-?\d+(\.\d+)?)|\/max:(-?\d+(\.\d+)?)|\/u:"([^"]+)"|\/e:([^\s]+)/g);
-    if (attrs) {
-      attrs.forEach(attr => {
-        if (attr.startsWith("/f:")) signals[name].scaling = parseFloat(attr.slice(3));
-        if (attr.startsWith("/o:")) signals[name].offset = parseFloat(attr.slice(3));
-        if (attr.startsWith("/min:")) signals[name].valueRange[0] = parseFloat(attr.slice(5));
-        if (attr.startsWith("/max:")) signals[name].valueRange[1] = parseFloat(attr.slice(5));
-        if (attr.startsWith("/u:")) signals[name].units = attr.slice(3).replace(/"/g, "");
-        if (attr.startsWith("/e:")) {
-          const en = attr.slice(3);
-          if (enumerations[en]) {
-            signals[name].valueDescriptions = { ...enumerations[en] };
-          }
+    // parse attributes: /f:, /o:, /min:, /max:, /u:, /e:
+    const attrs = line.match(
+      /\/[fo]:(-?\d+(\.\d+)?)|\/min:(-?\d+(\.\d+)?)|\/max:(-?\d+(\.\d+)?)|\/u:"([^"]+)"|\/e:([^\s]+)/g
+    ) || [];
+    attrs.forEach(attr => {
+      if (attr.startsWith("/f:")) {
+        signalsDefs[name].scaling = parseFloat(attr.slice(3));
+      }
+      if (attr.startsWith("/o:")) {
+        signalsDefs[name].offset = parseFloat(attr.slice(3));
+      }
+      if (attr.startsWith("/min:")) {
+        signalsDefs[name].valueRange[0] = parseFloat(attr.slice(5));
+      }
+      if (attr.startsWith("/max:")) {
+        signalsDefs[name].valueRange[1] = parseFloat(attr.slice(5));
+      }
+      if (attr.startsWith("/u:")) {
+        signalsDefs[name].units = attr.slice(3).replace(/"/g, "");
+      }
+      if (attr.startsWith("/e:")) {
+        const en = attr.slice(3);
+        if (enumerations[en]) {
+          signalsDefs[name].valueDescriptions = {
+            ...enumerations[en]
+          };
         }
-      });
-    }
+      }
+    });
 
-    // inline description
+    // inline description after //
     const desc = line.match(/\/\/\s*(.*)$/);
-    if (desc) signals[name].description = desc[1].trim();
+    if (desc) {
+      signalsDefs[name].description = desc[1].trim();
+    }
   }
 
-  // Third Pass: build messages (merge by name)
+  // 3) Third pass: build messages, merge repeated blocks
   const msgMap = {};
+  const muxValues = {}; // per-message map of { signalName: numericValue }
   let current = null;
 
-  for (let line of lines) {
-    // header
+  for (const line of lines) {
+    // [MessageName]
     const hdr = line.match(/^\[(.+)\]$/);
     if (hdr) {
       const name = hdr[1].replace(/"/g, "");
-      current = msgMap[name] || {
-        name,
-        id: null,
-        dlc: null,
-        sender: "Unknown",
-        isExtendedId: false,
-        signals: [],
-        muxDefinitions: [],
-      };
-      msgMap[name] = current;
+      if (!msgMap[name]) {
+        msgMap[name] = {
+          name,
+          id:             null,
+          rawId:          null,
+          isExtendedId:   false,
+          dlc:            null,
+          sender:         "Unknown",
+          comment:        undefined,
+          signals:        [],
+          muxDefinitions: []
+        };
+      }
+      current = msgMap[name];
       if (!messages.includes(current)) messages.push(current);
+      muxValues[name] = {};
       continue;
     }
     if (!current) continue;
 
-    // ID
+    // ID=123h // optional comment
     const idm = line.match(/^ID=([0-9A-Fa-f]+)h(?:\s*\/\/\s*(.*))?$/);
     if (idm) {
       const raw = parseInt(idm[1], 16);
-      current.id = `0x${raw.toString(16).toUpperCase()}`;
-      if (idm[2]) current.comment = idm[2].trim();
+      current.rawId = raw;
+      // default to standard (11-bit) mask
+      const masked = raw & 0x7FF;
+      current.id = "0x" + masked.toString(16).toUpperCase();
+      current.isExtendedId = false;
+      if (idm[2]) {
+        current.comment = idm[2].trim();
+      }
       continue;
     }
 
-    // Type
+    // Type=Standard|Extended
     const tm = line.match(/^Type=(Standard|Extended)$/);
-    if (tm && current.id) {
-      current.isExtendedId = tm[1] === "Extended";
-      let raw = parseInt(current.id, 16);
-      if (!current.isExtendedId) raw &= 0x7FF;
-      current.id = current.isExtendedId
-        ? `0x${raw.toString(16).toUpperCase().padStart(8, "0")}`
-        : `0x${raw.toString(16).toUpperCase().padStart(3, "0")}`;
+    if (tm && current.rawId !== null) {
+      const isExt = tm[1] === "Extended";
+      current.isExtendedId = isExt;
+      const mask = isExt ? 0x1FFFFFFF : 0x7FF;
+      const masked = current.rawId & mask;
+      if (isExt) {
+        // extended → pad to 8 hex digits
+        current.id = "0x" + masked.toString(16).toUpperCase().padStart(8, "0");
+      } else {
+        // standard → no zero-padding
+        current.id = "0x" + masked.toString(16).toUpperCase();
+      }
       continue;
     }
 
-    // Len
+    // Len=#
     const lm = line.match(/^Len=(\d+)$/);
     if (lm) {
       current.dlc = parseInt(lm[1], 10);
       continue;
     }
 
-    // Mux definitions (sets multiplexerValue on referenced signals)
-    const muxm = line.match(/^Mux=(\w+)\s+(\d+),(\d+)\s+([0-9A-Fa-f]+)h(\s+-m)?/);
+    // Mux=Name start,length hexh [-m]
+    const muxm = line.match(
+      /^Mux=(\w+)\s+(\d+),(\d+)\s+([0-9A-Fa-f]+)h(\s+-m)?$/
+    );
     if (muxm) {
-      const [, mname, sb, ln, hv, big] = muxm;
-      const val = parseInt(hv, 16);
-      // mark the mux signal itself
-      const muxSig = signals[mname];
-      if (muxSig) muxSig.isMultiplexer = true;
-      // assign multiplexerValue to all signals of this name
+      const [, mname, sb, ln, hv, bigFlag] = muxm;
+      const big = !!bigFlag;
+      const rawVal = parseInt(hv, 16);
+      const hexVal = "0x" +
+        rawVal.toString(16).toUpperCase().padStart(2, "0");
+
+      // record for later Sig/Var
+      muxValues[current.name][mname] = rawVal;
+
+      // push into muxDefinitions
       current.muxDefinitions.push({
-        name: mname,
+        name:     mname,
         startBit: parseInt(sb, 10),
-        length: parseInt(ln, 10),
-        value: `0x${val.toString(16).toUpperCase().padStart(2, "0")}`,
-        byteOrder: big ? "BigEndian" : "LittleEndian",
+        length:   parseInt(ln, 10),
+        value:    hexVal,
+        byteOrder: big ? "BigEndian" : "LittleEndian"
+      });
+      continue;
+    }
+
+    // Var=Name type start,length [attrs]
+    const vrm = line.match(/^Var=([^ ]+)\s+(\w+)\s+(\d+),(\d+)(.*)$/);
+    if (vrm) {
+      const [, vname, rawTypeRaw, sb, ln, rest] = vrm;
+      const startBit = parseInt(sb, 10);
+      const length   = parseInt(ln, 10);
+      const rt       = rawTypeRaw.toLowerCase();
+      const valueType =
+        rt === "string"   ? "String"   :
+        rt === "unsigned" ? "Unsigned" : "Signed";
+
+      const sig = {
+        name:             vname,
+        startBit,
+        length,
+        byteOrder:        "LittleEndian",
+        valueType,
+        scaling:          1.0,
+        offset:           0.0,
+        valueRange:       [0, 1],
+        units:            "",
+        description:      "",
+        valueDescriptions:{},
+        defaultValue:     0,
+        isMultiplexer:    false,
+        multiplexerValue: muxValues[current.name]?.[vname]
+      };
+
+      // same attr parsing as global Sig
+      const attrs2 = (rest.match(
+        /\/[fo]:(-?\d+(\.\d+)?)|\/min:(-?\d+(\.\d+)?)|\/max:(-?\d+(\.\d+)?)|\/u:"([^"]+)"|\/e:([^\s]+)/g
+      ) || []);
+      attrs2.forEach(attr => {
+        if (attr.startsWith("/f:")) {
+          sig.scaling = parseFloat(attr.slice(3));
+        }
+        if (attr.startsWith("/o:")) {
+          sig.offset = parseFloat(attr.slice(3));
+        }
+        if (attr.startsWith("/min:")) {
+          sig.valueRange[0] = parseFloat(attr.slice(5));
+        }
+        if (attr.startsWith("/max:")) {
+          sig.valueRange[1] = parseFloat(attr.slice(5));
+        }
+        if (attr.startsWith("/u:")) {
+          sig.units = attr.slice(3).replace(/"/g, "");
+        }
+        if (attr.startsWith("/e:")) {
+          const en = attr.slice(3);
+          if (enumerations[en]) {
+            sig.valueDescriptions = { ...enumerations[en] };
+          }
+        }
       });
-      // also annotate the matching signal references when they’re later attached
+
+      current.signals.push(sig);
       continue;
     }
 
-    // Sig references
+    // Sig="Name" bitPosition
     const srm = line.match(/^Sig="?([^"\s]+)"?\s+(\d+)/);
     if (srm) {
-      const nm = srm[1];
-      const sb = parseInt(srm[2], 10);
-      if (signals[nm]) {
-        // if this signal name has multiple multiplexed definitions,
-        // assign its current multiplexerValue based on the last Mux= for it
-        const lastMux = current.muxDefinitions.find(m => m.name === nm);
-        const sv = lastMux ? parseInt(lastMux.value, 16) : undefined;
-        current.signals.push({ ...signals[nm], startBit: sb, multiplexerValue: sv });
+      const [, nm, sbRaw] = srm;
+      const sb = parseInt(sbRaw, 10);
+      const def = signalsDefs[nm];
+      if (def) {
+        const mv = muxValues[current.name]?.[nm];
+        current.signals.push({
+          name:             def.name,
+          startBit:         sb,
+          length:           def.length,
+          byteOrder:        def.byteOrder,
+          valueType:        def.valueType,
+          scaling:          def.scaling,
+          offset:           def.offset,
+          valueRange:       [...def.valueRange],
+          units:            def.units,
+          defaultValue:     def.defaultValue,
+          multiplexerValue: mv,
+          valueDescriptions:{ ...def.valueDescriptions },
+          description:      def.description,
+          isMultiplexer:    def.isMultiplexer
+        });
       }
       continue;
     }
-  }
-
-  // Attach metadata, comments, descriptions here…
-  // (omitted for brevity; unchanged from earlier)
-
-  // --- NEW: group multiplexed signals just like parseDBC does ---
-  messages.forEach(msg => {
-    // find multiplexer field
-    const muxField = msg.signals.find(s => s.isMultiplexer);
-    if (!muxField) return;
 
-    msg.multiplexer = muxField.name;
+    // (You can parse TxNode= here if your SYM uses it to populate sender & nodes)
+  }
 
-    // group by multiplexerValue
-    const groups = {};
-    msg.signals.forEach(s => {
-      if (s.isMultiplexer) return;
-      const key = String(s.multiplexerValue ?? 0);
-      if (!groups[key]) groups[key] = [];
-      groups[key].push(s);
-    });
-    msg.multiplexedSignals = groups;
-
-    // reorder signals: mux first, then groups in numeric order
-    msg.signals = [
-      muxField,
-      ...Object.keys(groups)
-        .sort((a, b) => Number(a) - Number(b))
-        .flatMap(k => groups[k])
-    ];
-  });
-
-  // Keep any message with a valid ID
+  // 4) Filter out any message without a valid ID
   const clean = messages.filter(m => m.id != null);
 
+  // 5) Optionally sort by numeric ID
+  clean.sort((a, b) => parseInt(a.id, 16) - parseInt(b.id, 16));
+
   return {
-    formatVersion,
-    title,
     messages: clean,
-    nodes: Array.from(nodes),
+    nodes:    Array.from(nodes)
   };
-}
\ No newline at end of file
+}
diff --git a/app/tests/parser-sym.test.js b/app/tests/parser-sym.test.js
index 4bf7eab..b5246a7 100644
--- a/app/tests/parser-sym.test.js
+++ b/app/tests/parser-sym.test.js
@@ -544,20 +544,4 @@ test('parses multiple messages and checks node creation if applicable', () => {
     expect(c).toMatchObject({ name: 'OptionC', startBit: 16, length: 8, value: '0x03', byteOrder: 'LittleEndian' });
   });
 
-  // Validates parsing of file metadata generically
-  test('parses generic FormatVersion and Title', () => {
-    const content = `
-      FormatVersion=3.1
-      Title="Generic Database"
-
-      [MsgD]
-      ID=5h
-      Type=Standard
-      Len=1
-    `;
-    const parsedData = parseSYM(content);
-    expect(parsedData.formatVersion).toBe('3.1');
-    expect(parsedData.title).toBe('Generic Database');
-  });
-
 });
\ No newline at end of file
